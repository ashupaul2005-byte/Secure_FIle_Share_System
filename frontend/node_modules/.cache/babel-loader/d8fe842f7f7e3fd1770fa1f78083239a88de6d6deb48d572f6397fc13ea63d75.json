{"ast":null,"code":"// src/utils/crypto.js\n\nimport forge from 'node-forge';\n\n// --- Cryptography functions (these are unchanged) ---\n\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\n  const aesKey = forge.random.getBytesSync(32);\n  const iv = forge.random.getBytesSync(16);\n  const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\n  cipher.start({\n    iv: iv\n  });\n  cipher.update(forge.util.createBuffer(message, 'utf8'));\n  cipher.finish();\n  const encryptedMessage = cipher.output.getBytes();\n  const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\n  const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\n  return {\n    iv: forge.util.encode64(iv),\n    encryptedKey: forge.util.encode64(encryptedAesKey),\n    encryptedMessage: forge.util.encode64(encryptedMessage)\n  };\n};\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\n  const {\n    iv,\n    encryptedKey,\n    encryptedMessage\n  } = encryptedPayload;\n  const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n  const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\n  const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\n  decipher.start({\n    iv: forge.util.decode64(iv)\n  });\n  decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\n  decipher.finish();\n  return decipher.output.toString('utf8');\n};\n\n// --- NEW: BUILT-IN STEGANOGRAPHY LOGIC ---\n\nconst END_OF_MESSAGE = '$$EOM$$'; // A marker to know where the message ends\n\n// Helper function to load an image and get its pixel data\nconst getImageData = dataUrl => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous'; // Allow CORS for canvas pixel access\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0);\n      resolve({\n        imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),\n        ctx: ctx\n      });\n    };\n    img.onerror = error => {\n      console.error('Image loading error:', error);\n      reject(new Error('Failed to load image: ' + error));\n    };\n    img.src = dataUrl;\n  });\n};\n\n// Hides the data string inside an image's pixel data\nexport const hideDataInImage = async (imageDataUrl, data) => {\n  const {\n    imageData,\n    ctx\n  } = await getImageData(imageDataUrl);\n  const pixels = imageData.data;\n  const message = data + END_OF_MESSAGE;\n  let messageBits = '';\n  for (let i = 0; i < message.length; i++) {\n    messageBits += message.charCodeAt(i).toString(2).padStart(8, '0');\n  }\n  if (messageBits.length > pixels.length / 4) {\n    // We use one pixel per bit\n    throw new Error('Image is too small to hold the message.');\n  }\n  let bitIndex = 0;\n  for (let i = 0; i < pixels.length && bitIndex < messageBits.length; i += 4) {\n    // Modify the least significant bit of the red channel\n    pixels[i] = pixels[i] & 0xFE | parseInt(messageBits[bitIndex], 2);\n    bitIndex++;\n  }\n  ctx.putImageData(imageData, 0, 0);\n  return ctx.canvas.toDataURL();\n};\n\n// Extracts the hidden data from an image's pixel data\nexport const extractDataFromImage = async imageDataUrl => {\n  try {\n    const {\n      imageData\n    } = await getImageData(imageDataUrl);\n    const pixels = imageData.data;\n    let messageBits = '';\n\n    // Extract bits from red channel (every 4th pixel starting at 0)\n    for (let i = 0; i < pixels.length; i += 4) {\n      messageBits += (pixels[i] & 1).toString();\n    }\n    console.log('Extracted message bits length:', messageBits.length);\n    let message = '';\n    let consecutiveNulls = 0;\n\n    // Convert bits to characters\n    for (let i = 0; i < messageBits.length; i += 8) {\n      const byte = messageBits.substring(i, i + 8);\n      if (byte.length === 8) {\n        const charCode = parseInt(byte, 2);\n\n        // Stop if we hit too many null characters (indicates end of message)\n        if (charCode === 0) {\n          consecutiveNulls++;\n          if (consecutiveNulls > 10) {\n            console.log('Detected end of message (null characters)');\n            break;\n          }\n        } else {\n          consecutiveNulls = 0;\n          message += String.fromCharCode(charCode);\n        }\n      }\n    }\n    console.log('Decoded message length:', message.length);\n    console.log('Looking for END_OF_MESSAGE marker:', END_OF_MESSAGE);\n    const eomIndex = message.indexOf(END_OF_MESSAGE);\n    console.log('EOM index:', eomIndex);\n\n    // Try to find the marker\n    if (eomIndex !== -1) {\n      const extracted = message.substring(0, eomIndex);\n      console.log('Successfully extracted message of length:', extracted.length);\n      return extracted;\n    }\n\n    // If marker not found but we have a message, try to parse it anyway\n    // This handles cases where the marker got corrupted\n    if (message.length > 0) {\n      console.warn('END_OF_MESSAGE marker not found, but extracted data exists. Attempting to use as-is.');\n      // Try to parse as JSON\n      try {\n        const parsed = JSON.parse(message);\n        console.log('Successfully parsed as JSON without marker');\n        return message;\n      } catch (e) {\n        // Return first reasonable chunk\n        const cleaned = message.split('\\x00')[0]; // Split on null character\n        if (cleaned.length > 20) {\n          console.log('Extracted cleaned message of length:', cleaned.length);\n          return cleaned;\n        }\n      }\n    }\n    throw new Error('End of message marker not found and no valid data extracted. Message length: ' + message.length);\n  } catch (error) {\n    console.error('Full extraction error:', error);\n    throw new Error('Failed to extract data from image: ' + error.message);\n  }\n};\n\n// ========== VIDEO STEGANOGRAPHY FUNCTIONS ==========\n\n// Extract a frame from video at a specific timestamp\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\n  return new Promise((resolve, reject) => {\n    const video = document.createElement('video');\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    video.onloadedmetadata = () => {\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);\n    };\n    video.onseeked = () => {\n      try {\n        ctx.drawImage(video, 0, 0);\n        const frameDataUrl = canvas.toDataURL('image/png');\n        console.log('Frame extracted successfully, data URL length:', frameDataUrl.length);\n        resolve(frameDataUrl);\n      } catch (error) {\n        reject(new Error('Failed to draw frame on canvas: ' + error.message));\n      }\n    };\n    video.onerror = error => {\n      reject(new Error('Video loading error: ' + error.message));\n    };\n    try {\n      video.src = URL.createObjectURL(videoFile);\n      video.currentTime = frameTimestamp;\n    } catch (error) {\n      reject(new Error('Failed to set video source: ' + error.message));\n    }\n  });\n};\n\n// Hide message in a random frame of the video\nexport const hideDataInVideoFrame = async (videoFile, data) => {\n  try {\n    // Get video duration\n    const video = document.createElement('video');\n    video.src = URL.createObjectURL(videoFile);\n    return new Promise((resolve, reject) => {\n      video.onloadedmetadata = async () => {\n        const duration = video.duration;\n\n        // Generate a random frame position (in seconds)\n        // Avoid first and last second for better hiding\n        const randomFrameTimestamp = Math.random() * (duration - 2) + 1;\n        try {\n          // Extract the frame at the random timestamp\n          const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\n\n          // Hide the message in that frame\n          const stegoFrameDataUrl = await hideDataInImage(frameDataUrl, data);\n\n          // Package metadata about the frame location\n          const frameMetadata = {\n            frameTimestamp: randomFrameTimestamp,\n            encryptedData: data\n          };\n          resolve({\n            stegoFrame: stegoFrameDataUrl,\n            frameMetadata: frameMetadata,\n            originalVideo: videoFile\n          });\n        } catch (error) {\n          reject(error);\n        }\n      };\n      video.onerror = reject;\n    });\n  } catch (error) {\n    throw new Error('Failed to process video: ' + error.message);\n  }\n};\n\n// Extract hidden data from a video file and frame timestamp\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\n  try {\n    // Extract the frame at the specified timestamp\n    const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\n\n    // Extract hidden data from that frame\n    const encryptedDataString = await extractDataFromImage(frameDataUrl);\n    return encryptedDataString;\n  } catch (error) {\n    throw new Error('Failed to extract data from video: ' + error.message);\n  }\n};\n\n// Create a modified video with steganographic frame\n// This function embeds the stego-frame back into the video at the same position\nexport const embedStegoFrameIntoVideo = async (originalVideoFile, stegoFrameDataUrl, frameTimestamp) => {\n  // For simplicity in this implementation, we'll return the metadata separately\n  // In a production system, you'd use FFmpeg to actually modify the video file\n  // For now, we store the frame index and send it along with the video\n\n  const stegoFrameBlob = await fetch(stegoFrameDataUrl).then(r => r.blob());\n  return {\n    videoFile: originalVideoFile,\n    stegoFrame: stegoFrameBlob,\n    frameTimestamp: frameTimestamp\n  };\n};","map":{"version":3,"names":["forge","encryptMessage","message","recipientPublicKeyPem","aesKey","random","getBytesSync","iv","cipher","createCipher","start","update","util","createBuffer","finish","encryptedMessage","output","getBytes","recipientPublicKey","pki","publicKeyFromPem","encryptedAesKey","encrypt","encode64","encryptedKey","decryptMessage","encryptedPayload","privateKeyPem","privateKey","privateKeyFromPem","decrypt","decode64","decipher","createDecipher","toString","END_OF_MESSAGE","getImageData","dataUrl","Promise","resolve","reject","img","Image","crossOrigin","onload","canvas","document","createElement","width","height","ctx","getContext","drawImage","imageData","onerror","error","console","Error","src","hideDataInImage","imageDataUrl","data","pixels","messageBits","i","length","charCodeAt","padStart","bitIndex","parseInt","putImageData","toDataURL","extractDataFromImage","log","consecutiveNulls","byte","substring","charCode","String","fromCharCode","eomIndex","indexOf","extracted","warn","parsed","JSON","parse","e","cleaned","split","extractVideoFrame","videoFile","frameTimestamp","video","onloadedmetadata","videoWidth","videoHeight","onseeked","frameDataUrl","URL","createObjectURL","currentTime","hideDataInVideoFrame","duration","randomFrameTimestamp","Math","stegoFrameDataUrl","frameMetadata","encryptedData","stegoFrame","originalVideo","extractDataFromVideo","encryptedDataString","embedStegoFrameIntoVideo","originalVideoFile","stegoFrameBlob","fetch","then","r","blob"],"sources":["D:/secure-chat-app/frontend/src/utils/crypto.js"],"sourcesContent":["// src/utils/crypto.js\r\n\r\nimport forge from 'node-forge';\r\n\r\n// --- Cryptography functions (these are unchanged) ---\r\n\r\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\r\n    const aesKey = forge.random.getBytesSync(32);\r\n    const iv = forge.random.getBytesSync(16);\r\n    const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\r\n    cipher.start({ iv: iv });\r\n    cipher.update(forge.util.createBuffer(message, 'utf8'));\r\n    cipher.finish();\r\n    const encryptedMessage = cipher.output.getBytes();\r\n    const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\r\n    const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\r\n    return {\r\n        iv: forge.util.encode64(iv),\r\n        encryptedKey: forge.util.encode64(encryptedAesKey),\r\n        encryptedMessage: forge.util.encode64(encryptedMessage),\r\n    };\r\n};\r\n\r\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\r\n    const { iv, encryptedKey, encryptedMessage } = encryptedPayload;\r\n    const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\r\n    const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\r\n    const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\r\n    decipher.start({ iv: forge.util.decode64(iv) });\r\n    decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\r\n    decipher.finish();\r\n    return decipher.output.toString('utf8');\r\n};\r\n\r\n// --- NEW: BUILT-IN STEGANOGRAPHY LOGIC ---\r\n\r\nconst END_OF_MESSAGE = '$$EOM$$'; // A marker to know where the message ends\r\n\r\n// Helper function to load an image and get its pixel data\r\nconst getImageData = (dataUrl) => {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = 'anonymous'; // Allow CORS for canvas pixel access\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0);\r\n            resolve({\r\n                imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),\r\n                ctx: ctx\r\n            });\r\n        };\r\n        img.onerror = (error) => {\r\n            console.error('Image loading error:', error);\r\n            reject(new Error('Failed to load image: ' + error));\r\n        };\r\n        img.src = dataUrl;\r\n    });\r\n};\r\n\r\n// Hides the data string inside an image's pixel data\r\nexport const hideDataInImage = async (imageDataUrl, data) => {\r\n    const { imageData, ctx } = await getImageData(imageDataUrl);\r\n    const pixels = imageData.data;\r\n    const message = data + END_OF_MESSAGE;\r\n    let messageBits = '';\r\n    for (let i = 0; i < message.length; i++) {\r\n        messageBits += message.charCodeAt(i).toString(2).padStart(8, '0');\r\n    }\r\n\r\n    if (messageBits.length > pixels.length / 4) { // We use one pixel per bit\r\n        throw new Error('Image is too small to hold the message.');\r\n    }\r\n\r\n    let bitIndex = 0;\r\n    for (let i = 0; i < pixels.length && bitIndex < messageBits.length; i += 4) {\r\n        // Modify the least significant bit of the red channel\r\n        pixels[i] = (pixels[i] & 0xFE) | parseInt(messageBits[bitIndex], 2);\r\n        bitIndex++;\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n    return ctx.canvas.toDataURL();\r\n};\r\n\r\n// Extracts the hidden data from an image's pixel data\r\nexport const extractDataFromImage = async (imageDataUrl) => {\r\n    try {\r\n        const { imageData } = await getImageData(imageDataUrl);\r\n        const pixels = imageData.data;\r\n        let messageBits = '';\r\n\r\n        // Extract bits from red channel (every 4th pixel starting at 0)\r\n        for (let i = 0; i < pixels.length; i += 4) {\r\n            messageBits += (pixels[i] & 1).toString();\r\n        }\r\n\r\n        console.log('Extracted message bits length:', messageBits.length);\r\n\r\n        let message = '';\r\n        let consecutiveNulls = 0;\r\n        \r\n        // Convert bits to characters\r\n        for (let i = 0; i < messageBits.length; i += 8) {\r\n            const byte = messageBits.substring(i, i + 8);\r\n            if (byte.length === 8) {\r\n                const charCode = parseInt(byte, 2);\r\n                \r\n                // Stop if we hit too many null characters (indicates end of message)\r\n                if (charCode === 0) {\r\n                    consecutiveNulls++;\r\n                    if (consecutiveNulls > 10) {\r\n                        console.log('Detected end of message (null characters)');\r\n                        break;\r\n                    }\r\n                } else {\r\n                    consecutiveNulls = 0;\r\n                    message += String.fromCharCode(charCode);\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log('Decoded message length:', message.length);\r\n        console.log('Looking for END_OF_MESSAGE marker:', END_OF_MESSAGE);\r\n        \r\n        const eomIndex = message.indexOf(END_OF_MESSAGE);\r\n        console.log('EOM index:', eomIndex);\r\n        \r\n        // Try to find the marker\r\n        if (eomIndex !== -1) {\r\n            const extracted = message.substring(0, eomIndex);\r\n            console.log('Successfully extracted message of length:', extracted.length);\r\n            return extracted;\r\n        }\r\n\r\n        // If marker not found but we have a message, try to parse it anyway\r\n        // This handles cases where the marker got corrupted\r\n        if (message.length > 0) {\r\n            console.warn('END_OF_MESSAGE marker not found, but extracted data exists. Attempting to use as-is.');\r\n            // Try to parse as JSON\r\n            try {\r\n                const parsed = JSON.parse(message);\r\n                console.log('Successfully parsed as JSON without marker');\r\n                return message;\r\n            } catch (e) {\r\n                // Return first reasonable chunk\r\n                const cleaned = message.split('\\x00')[0]; // Split on null character\r\n                if (cleaned.length > 20) {\r\n                    console.log('Extracted cleaned message of length:', cleaned.length);\r\n                    return cleaned;\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error('End of message marker not found and no valid data extracted. Message length: ' + message.length);\r\n    } catch (error) {\r\n        console.error('Full extraction error:', error);\r\n        throw new Error('Failed to extract data from image: ' + error.message);\r\n    }\r\n};\r\n\r\n// ========== VIDEO STEGANOGRAPHY FUNCTIONS ==========\r\n\r\n// Extract a frame from video at a specific timestamp\r\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\r\n    return new Promise((resolve, reject) => {\r\n        const video = document.createElement('video');\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        video.onloadedmetadata = () => {\r\n            canvas.width = video.videoWidth;\r\n            canvas.height = video.videoHeight;\r\n            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);\r\n        };\r\n\r\n        video.onseeked = () => {\r\n            try {\r\n                ctx.drawImage(video, 0, 0);\r\n                const frameDataUrl = canvas.toDataURL('image/png');\r\n                console.log('Frame extracted successfully, data URL length:', frameDataUrl.length);\r\n                resolve(frameDataUrl);\r\n            } catch (error) {\r\n                reject(new Error('Failed to draw frame on canvas: ' + error.message));\r\n            }\r\n        };\r\n\r\n        video.onerror = (error) => {\r\n            reject(new Error('Video loading error: ' + error.message));\r\n        };\r\n        \r\n        try {\r\n            video.src = URL.createObjectURL(videoFile);\r\n            video.currentTime = frameTimestamp;\r\n        } catch (error) {\r\n            reject(new Error('Failed to set video source: ' + error.message));\r\n        }\r\n    });\r\n};\r\n\r\n// Hide message in a random frame of the video\r\nexport const hideDataInVideoFrame = async (videoFile, data) => {\r\n    try {\r\n        // Get video duration\r\n        const video = document.createElement('video');\r\n        video.src = URL.createObjectURL(videoFile);\r\n        \r\n        return new Promise((resolve, reject) => {\r\n            video.onloadedmetadata = async () => {\r\n                const duration = video.duration;\r\n                \r\n                // Generate a random frame position (in seconds)\r\n                // Avoid first and last second for better hiding\r\n                const randomFrameTimestamp = Math.random() * (duration - 2) + 1;\r\n                \r\n                try {\r\n                    // Extract the frame at the random timestamp\r\n                    const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\r\n                    \r\n                    // Hide the message in that frame\r\n                    const stegoFrameDataUrl = await hideDataInImage(frameDataUrl, data);\r\n                    \r\n                    // Package metadata about the frame location\r\n                    const frameMetadata = {\r\n                        frameTimestamp: randomFrameTimestamp,\r\n                        encryptedData: data\r\n                    };\r\n                    \r\n                    resolve({\r\n                        stegoFrame: stegoFrameDataUrl,\r\n                        frameMetadata: frameMetadata,\r\n                        originalVideo: videoFile\r\n                    });\r\n                } catch (error) {\r\n                    reject(error);\r\n                }\r\n            };\r\n            \r\n            video.onerror = reject;\r\n        });\r\n    } catch (error) {\r\n        throw new Error('Failed to process video: ' + error.message);\r\n    }\r\n};\r\n\r\n// Extract hidden data from a video file and frame timestamp\r\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\r\n    try {\r\n        // Extract the frame at the specified timestamp\r\n        const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\r\n        \r\n        // Extract hidden data from that frame\r\n        const encryptedDataString = await extractDataFromImage(frameDataUrl);\r\n        \r\n        return encryptedDataString;\r\n    } catch (error) {\r\n        throw new Error('Failed to extract data from video: ' + error.message);\r\n    }\r\n};\r\n\r\n// Create a modified video with steganographic frame\r\n// This function embeds the stego-frame back into the video at the same position\r\nexport const embedStegoFrameIntoVideo = async (originalVideoFile, stegoFrameDataUrl, frameTimestamp) => {\r\n    // For simplicity in this implementation, we'll return the metadata separately\r\n    // In a production system, you'd use FFmpeg to actually modify the video file\r\n    // For now, we store the frame index and send it along with the video\r\n    \r\n    const stegoFrameBlob = await fetch(stegoFrameDataUrl).then(r => r.blob());\r\n    \r\n    return {\r\n        videoFile: originalVideoFile,\r\n        stegoFrame: stegoFrameBlob,\r\n        frameTimestamp: frameTimestamp\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}