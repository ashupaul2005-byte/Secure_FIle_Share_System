{"ast":null,"code":"// src/utils/crypto.js\n\nimport forge from 'node-forge';\n\n// --- Cryptography functions (these are unchanged) ---\n\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\n  const aesKey = forge.random.getBytesSync(32);\n  const iv = forge.random.getBytesSync(16);\n  const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\n  cipher.start({\n    iv: iv\n  });\n  cipher.update(forge.util.createBuffer(message, 'utf8'));\n  cipher.finish();\n  const encryptedMessage = cipher.output.getBytes();\n  const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\n  const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\n  return {\n    iv: forge.util.encode64(iv),\n    encryptedKey: forge.util.encode64(encryptedAesKey),\n    encryptedMessage: forge.util.encode64(encryptedMessage)\n  };\n};\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\n  const {\n    iv,\n    encryptedKey,\n    encryptedMessage\n  } = encryptedPayload;\n  const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n  const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\n  const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\n  decipher.start({\n    iv: forge.util.decode64(iv)\n  });\n  decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\n  decipher.finish();\n  return decipher.output.toString('utf8');\n};\n\n// --- NEW: BUILT-IN STEGANOGRAPHY LOGIC ---\n\nconst END_OF_MESSAGE = '$$EOM$$'; // A marker to know where the message ends\n\n// Helper function to load an image and get its pixel data\nconst getImageData = dataUrl => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0);\n      resolve({\n        imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),\n        ctx: ctx\n      });\n    };\n    img.onerror = reject;\n    img.src = dataUrl;\n  });\n};\n\n// Hides the data string inside an image's pixel data\nexport const hideDataInImage = async (imageDataUrl, data) => {\n  const {\n    imageData,\n    ctx\n  } = await getImageData(imageDataUrl);\n  const pixels = imageData.data;\n  const message = data + END_OF_MESSAGE;\n  let messageBits = '';\n  for (let i = 0; i < message.length; i++) {\n    messageBits += message.charCodeAt(i).toString(2).padStart(8, '0');\n  }\n  if (messageBits.length > pixels.length / 4) {\n    // We use one pixel per bit\n    throw new Error('Image is too small to hold the message.');\n  }\n  let bitIndex = 0;\n  for (let i = 0; i < pixels.length && bitIndex < messageBits.length; i += 4) {\n    // Modify the least significant bit of the red channel\n    pixels[i] = pixels[i] & 0xFE | parseInt(messageBits[bitIndex], 2);\n    bitIndex++;\n  }\n  ctx.putImageData(imageData, 0, 0);\n  return ctx.canvas.toDataURL();\n};\n\n// Extracts the hidden data from an image's pixel data\nexport const extractDataFromImage = async imageDataUrl => {\n  const {\n    imageData\n  } = await getImageData(imageDataUrl);\n  const pixels = imageData.data;\n  let messageBits = '';\n  for (let i = 0; i < pixels.length; i += 4) {\n    messageBits += (pixels[i] & 1).toString();\n  }\n  let message = '';\n  for (let i = 0; i < messageBits.length; i += 8) {\n    const byte = messageBits.substring(i, i + 8);\n    if (byte.length === 8) {\n      message += String.fromCharCode(parseInt(byte, 2));\n    }\n  }\n  const eomIndex = message.indexOf(END_OF_MESSAGE);\n  if (eomIndex !== -1) {\n    return message.substring(0, eomIndex);\n  }\n  throw new Error('End of message marker not found.');\n};\n\n// ========== VIDEO STEGANOGRAPHY FUNCTIONS ==========\n\n// Extract a frame from video at a specific timestamp\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\n  return new Promise((resolve, reject) => {\n    const video = document.createElement('video');\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    video.onloadedmetadata = () => {\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n    };\n    video.onseeked = () => {\n      ctx.drawImage(video, 0, 0);\n      const frameDataUrl = canvas.toDataURL('image/png');\n      resolve(frameDataUrl);\n    };\n    video.onerror = reject;\n    video.src = URL.createObjectURL(videoFile);\n    video.currentTime = frameTimestamp;\n  });\n};\n\n// Hide message in a random frame of the video\nexport const hideDataInVideoFrame = async (videoFile, data) => {\n  try {\n    // Get video duration\n    const video = document.createElement('video');\n    video.src = URL.createObjectURL(videoFile);\n    return new Promise((resolve, reject) => {\n      video.onloadedmetadata = async () => {\n        const duration = video.duration;\n\n        // Generate a random frame position (in seconds)\n        // Avoid first and last second for better hiding\n        const randomFrameTimestamp = Math.random() * (duration - 2) + 1;\n        try {\n          // Extract the frame at the random timestamp\n          const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\n\n          // Hide the message in that frame\n          const stegoFrameDataUrl = await hideDataInImage(frameDataUrl, data);\n\n          // Package metadata about the frame location\n          const frameMetadata = {\n            frameTimestamp: randomFrameTimestamp,\n            encryptedData: data\n          };\n          resolve({\n            stegoFrame: stegoFrameDataUrl,\n            frameMetadata: frameMetadata,\n            originalVideo: videoFile\n          });\n        } catch (error) {\n          reject(error);\n        }\n      };\n      video.onerror = reject;\n    });\n  } catch (error) {\n    throw new Error('Failed to process video: ' + error.message);\n  }\n};\n\n// Extract hidden data from a video file and frame timestamp\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\n  try {\n    // Extract the frame at the specified timestamp\n    const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\n\n    // Extract hidden data from that frame\n    const encryptedDataString = await extractDataFromImage(frameDataUrl);\n    return encryptedDataString;\n  } catch (error) {\n    throw new Error('Failed to extract data from video: ' + error.message);\n  }\n};\n\n// Create a modified video with steganographic frame\n// This function embeds the stego-frame back into the video at the same position\nexport const embedStegoFrameIntoVideo = async (originalVideoFile, stegoFrameDataUrl, frameTimestamp) => {\n  // For simplicity in this implementation, we'll return the metadata separately\n  // In a production system, you'd use FFmpeg to actually modify the video file\n  // For now, we store the frame index and send it along with the video\n\n  const stegoFrameBlob = await fetch(stegoFrameDataUrl).then(r => r.blob());\n  return {\n    videoFile: originalVideoFile,\n    stegoFrame: stegoFrameBlob,\n    frameTimestamp: frameTimestamp\n  };\n};","map":{"version":3,"names":["forge","encryptMessage","message","recipientPublicKeyPem","aesKey","random","getBytesSync","iv","cipher","createCipher","start","update","util","createBuffer","finish","encryptedMessage","output","getBytes","recipientPublicKey","pki","publicKeyFromPem","encryptedAesKey","encrypt","encode64","encryptedKey","decryptMessage","encryptedPayload","privateKeyPem","privateKey","privateKeyFromPem","decrypt","decode64","decipher","createDecipher","toString","END_OF_MESSAGE","getImageData","dataUrl","Promise","resolve","reject","img","Image","onload","canvas","document","createElement","width","height","ctx","getContext","drawImage","imageData","onerror","src","hideDataInImage","imageDataUrl","data","pixels","messageBits","i","length","charCodeAt","padStart","Error","bitIndex","parseInt","putImageData","toDataURL","extractDataFromImage","byte","substring","String","fromCharCode","eomIndex","indexOf","extractVideoFrame","videoFile","frameTimestamp","video","onloadedmetadata","videoWidth","videoHeight","onseeked","frameDataUrl","URL","createObjectURL","currentTime","hideDataInVideoFrame","duration","randomFrameTimestamp","Math","stegoFrameDataUrl","frameMetadata","encryptedData","stegoFrame","originalVideo","error","extractDataFromVideo","encryptedDataString","embedStegoFrameIntoVideo","originalVideoFile","stegoFrameBlob","fetch","then","r","blob"],"sources":["D:/secure-chat-app/frontend/src/utils/crypto.js"],"sourcesContent":["// src/utils/crypto.js\r\n\r\nimport forge from 'node-forge';\r\n\r\n// --- Cryptography functions (these are unchanged) ---\r\n\r\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\r\n    const aesKey = forge.random.getBytesSync(32);\r\n    const iv = forge.random.getBytesSync(16);\r\n    const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\r\n    cipher.start({ iv: iv });\r\n    cipher.update(forge.util.createBuffer(message, 'utf8'));\r\n    cipher.finish();\r\n    const encryptedMessage = cipher.output.getBytes();\r\n    const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\r\n    const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\r\n    return {\r\n        iv: forge.util.encode64(iv),\r\n        encryptedKey: forge.util.encode64(encryptedAesKey),\r\n        encryptedMessage: forge.util.encode64(encryptedMessage),\r\n    };\r\n};\r\n\r\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\r\n    const { iv, encryptedKey, encryptedMessage } = encryptedPayload;\r\n    const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\r\n    const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\r\n    const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\r\n    decipher.start({ iv: forge.util.decode64(iv) });\r\n    decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\r\n    decipher.finish();\r\n    return decipher.output.toString('utf8');\r\n};\r\n\r\n// --- NEW: BUILT-IN STEGANOGRAPHY LOGIC ---\r\n\r\nconst END_OF_MESSAGE = '$$EOM$$'; // A marker to know where the message ends\r\n\r\n// Helper function to load an image and get its pixel data\r\nconst getImageData = (dataUrl) => {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0);\r\n            resolve({\r\n                imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),\r\n                ctx: ctx\r\n            });\r\n        };\r\n        img.onerror = reject;\r\n        img.src = dataUrl;\r\n    });\r\n};\r\n\r\n// Hides the data string inside an image's pixel data\r\nexport const hideDataInImage = async (imageDataUrl, data) => {\r\n    const { imageData, ctx } = await getImageData(imageDataUrl);\r\n    const pixels = imageData.data;\r\n    const message = data + END_OF_MESSAGE;\r\n    let messageBits = '';\r\n    for (let i = 0; i < message.length; i++) {\r\n        messageBits += message.charCodeAt(i).toString(2).padStart(8, '0');\r\n    }\r\n\r\n    if (messageBits.length > pixels.length / 4) { // We use one pixel per bit\r\n        throw new Error('Image is too small to hold the message.');\r\n    }\r\n\r\n    let bitIndex = 0;\r\n    for (let i = 0; i < pixels.length && bitIndex < messageBits.length; i += 4) {\r\n        // Modify the least significant bit of the red channel\r\n        pixels[i] = (pixels[i] & 0xFE) | parseInt(messageBits[bitIndex], 2);\r\n        bitIndex++;\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n    return ctx.canvas.toDataURL();\r\n};\r\n\r\n// Extracts the hidden data from an image's pixel data\r\nexport const extractDataFromImage = async (imageDataUrl) => {\r\n    const { imageData } = await getImageData(imageDataUrl);\r\n    const pixels = imageData.data;\r\n    let messageBits = '';\r\n\r\n    for (let i = 0; i < pixels.length; i += 4) {\r\n        messageBits += (pixels[i] & 1).toString();\r\n    }\r\n\r\n    let message = '';\r\n    for (let i = 0; i < messageBits.length; i += 8) {\r\n        const byte = messageBits.substring(i, i + 8);\r\n        if (byte.length === 8) {\r\n            message += String.fromCharCode(parseInt(byte, 2));\r\n        }\r\n    }\r\n\r\n    const eomIndex = message.indexOf(END_OF_MESSAGE);\r\n    if (eomIndex !== -1) {\r\n        return message.substring(0, eomIndex);\r\n    }\r\n\r\n    throw new Error('End of message marker not found.');\r\n};\r\n\r\n// ========== VIDEO STEGANOGRAPHY FUNCTIONS ==========\r\n\r\n// Extract a frame from video at a specific timestamp\r\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\r\n    return new Promise((resolve, reject) => {\r\n        const video = document.createElement('video');\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        video.onloadedmetadata = () => {\r\n            canvas.width = video.videoWidth;\r\n            canvas.height = video.videoHeight;\r\n        };\r\n\r\n        video.onseeked = () => {\r\n            ctx.drawImage(video, 0, 0);\r\n            const frameDataUrl = canvas.toDataURL('image/png');\r\n            resolve(frameDataUrl);\r\n        };\r\n\r\n        video.onerror = reject;\r\n        video.src = URL.createObjectURL(videoFile);\r\n        video.currentTime = frameTimestamp;\r\n    });\r\n};\r\n\r\n// Hide message in a random frame of the video\r\nexport const hideDataInVideoFrame = async (videoFile, data) => {\r\n    try {\r\n        // Get video duration\r\n        const video = document.createElement('video');\r\n        video.src = URL.createObjectURL(videoFile);\r\n        \r\n        return new Promise((resolve, reject) => {\r\n            video.onloadedmetadata = async () => {\r\n                const duration = video.duration;\r\n                \r\n                // Generate a random frame position (in seconds)\r\n                // Avoid first and last second for better hiding\r\n                const randomFrameTimestamp = Math.random() * (duration - 2) + 1;\r\n                \r\n                try {\r\n                    // Extract the frame at the random timestamp\r\n                    const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\r\n                    \r\n                    // Hide the message in that frame\r\n                    const stegoFrameDataUrl = await hideDataInImage(frameDataUrl, data);\r\n                    \r\n                    // Package metadata about the frame location\r\n                    const frameMetadata = {\r\n                        frameTimestamp: randomFrameTimestamp,\r\n                        encryptedData: data\r\n                    };\r\n                    \r\n                    resolve({\r\n                        stegoFrame: stegoFrameDataUrl,\r\n                        frameMetadata: frameMetadata,\r\n                        originalVideo: videoFile\r\n                    });\r\n                } catch (error) {\r\n                    reject(error);\r\n                }\r\n            };\r\n            \r\n            video.onerror = reject;\r\n        });\r\n    } catch (error) {\r\n        throw new Error('Failed to process video: ' + error.message);\r\n    }\r\n};\r\n\r\n// Extract hidden data from a video file and frame timestamp\r\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\r\n    try {\r\n        // Extract the frame at the specified timestamp\r\n        const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\r\n        \r\n        // Extract hidden data from that frame\r\n        const encryptedDataString = await extractDataFromImage(frameDataUrl);\r\n        \r\n        return encryptedDataString;\r\n    } catch (error) {\r\n        throw new Error('Failed to extract data from video: ' + error.message);\r\n    }\r\n};\r\n\r\n// Create a modified video with steganographic frame\r\n// This function embeds the stego-frame back into the video at the same position\r\nexport const embedStegoFrameIntoVideo = async (originalVideoFile, stegoFrameDataUrl, frameTimestamp) => {\r\n    // For simplicity in this implementation, we'll return the metadata separately\r\n    // In a production system, you'd use FFmpeg to actually modify the video file\r\n    // For now, we store the frame index and send it along with the video\r\n    \r\n    const stegoFrameBlob = await fetch(stegoFrameDataUrl).then(r => r.blob());\r\n    \r\n    return {\r\n        videoFile: originalVideoFile,\r\n        stegoFrame: stegoFrameBlob,\r\n        frameTimestamp: frameTimestamp\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}