{"ast":null,"code":"// src/utils/crypto.js\nimport forge from 'node-forge';\n\n// -------------------- Crypto helpers --------------------\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\n  const aesKey = forge.random.getBytesSync(32);\n  const iv = forge.random.getBytesSync(16);\n  const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\n  cipher.start({\n    iv\n  });\n  cipher.update(forge.util.createBuffer(message, 'utf8'));\n  cipher.finish();\n  const encryptedMessage = cipher.output.getBytes();\n  const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\n  const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\n  return {\n    iv: forge.util.encode64(iv),\n    encryptedKey: forge.util.encode64(encryptedAesKey),\n    encryptedMessage: forge.util.encode64(encryptedMessage)\n  };\n};\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\n  const {\n    iv,\n    encryptedKey,\n    encryptedMessage\n  } = encryptedPayload;\n  const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n  const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\n  const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\n  decipher.start({\n    iv: forge.util.decode64(iv)\n  });\n  decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\n  decipher.finish();\n  return decipher.output.toString('utf8');\n};\n\n// -------------------- Stego helpers --------------------\nconst END_OF_MESSAGE = '$$EOM$$';\n\n// UTF-8 <-> base64 helpers that are safe for arbitrary Unicode\nconst utf8ToBase64 = str => {\n  // encodeURIComponent -> percent-encoding -> decode percent into raw bytes for btoa\n  return btoa(unescape(encodeURIComponent(str)));\n};\nconst base64ToUtf8 = b64 => {\n  return decodeURIComponent(escape(atob(b64)));\n};\n\n// load an image (dataURL) and return imageData + canvas context\nconst getImageData = dataUrl => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0);\n      resolve({\n        imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),\n        ctx\n      });\n    };\n    img.onerror = err => reject(new Error('Image load error: ' + (err === null || err === void 0 ? void 0 : err.message) || err));\n    img.src = dataUrl;\n  });\n};\n\n// -------------------- Image steganography (3 bits per pixel: R,G,B) --------------------\n\n// hideDataInImage: imageDataUrl (dataURL string), data: string (already JSON/stringified)\n// We will base64-encode the data inside this function to make it safe for embedding.\nexport const hideDataInImage = async (imageDataUrl, data) => {\n  // encode data as base64 (UTF-8 safe) and append marker\n  const payload = utf8ToBase64(data) + END_OF_MESSAGE;\n  // convert to bit string\n  let messageBits = '';\n  for (let i = 0; i < payload.length; i++) {\n    const charCode = payload.charCodeAt(i);\n    messageBits += charCode.toString(2).padStart(8, '0');\n  }\n  const {\n    imageData,\n    ctx\n  } = await getImageData(imageDataUrl);\n  const pixels = imageData.data; // RGBA array\n  const numPixels = pixels.length / 4;\n  const capacityBits = numPixels * 3; // using R,G,B LSBs\n\n  if (messageBits.length > capacityBits) {\n    throw new Error(`Image too small. Need ${messageBits.length} bits but only ${capacityBits} bits available. ` + `Use a larger image or shorten the message.`);\n  }\n  let bitIndex = 0;\n  // iterate pixels, set LSBs of R,G,B channels\n  for (let px = 0; px < pixels.length && bitIndex < messageBits.length; px += 4) {\n    // R channel\n    if (bitIndex < messageBits.length) {\n      const bit = +messageBits[bitIndex++];\n      pixels[px] = pixels[px] & 0xfe | bit;\n    }\n    // G channel\n    if (bitIndex < messageBits.length) {\n      const bit = +messageBits[bitIndex++];\n      pixels[px + 1] = pixels[px + 1] & 0xfe | bit;\n    }\n    // B channel\n    if (bitIndex < messageBits.length) {\n      const bit = +messageBits[bitIndex++];\n      pixels[px + 2] = pixels[px + 2] & 0xfe | bit;\n    }\n    // leave alpha channel unchanged (px+3)\n  }\n  ctx.putImageData(imageData, 0, 0);\n  return ctx.canvas.toDataURL('image/png');\n};\n\n// extractDataFromImage: returns the base64-encoded payload (WITHOUT END marker) as a string\nexport const extractDataFromImage = async imageDataUrl => {\n  try {\n    const {\n      imageData\n    } = await getImageData(imageDataUrl);\n    const pixels = imageData.data;\n    const numPixels = pixels.length / 4;\n    const capacityBits = numPixels * 3;\n\n    // read bits from R,G,B LSBs\n    let bits = '';\n    for (let px = 0; px < pixels.length; px += 4) {\n      bits += (pixels[px] & 1).toString();\n      bits += (pixels[px + 1] & 1).toString();\n      bits += (pixels[px + 2] & 1).toString();\n    }\n    console.log('Extracted message bits length:', bits.length);\n\n    // convert bits to chars\n    let message = '';\n    for (let i = 0; i < bits.length; i += 8) {\n      const byte = bits.substring(i, i + 8);\n      if (byte.length < 8) break;\n      const code = parseInt(byte, 2);\n      message += String.fromCharCode(code);\n    }\n    console.log('Decoded message length:', message.length);\n    console.log('Looking for END_OF_MESSAGE marker:', END_OF_MESSAGE);\n    const eomIndex = message.indexOf(END_OF_MESSAGE);\n    console.log('EOM index:', eomIndex);\n    if (eomIndex !== -1) {\n      const extractedB64 = message.substring(0, eomIndex);\n      // convert base64 back to utf8 string\n      const decoded = base64ToUtf8(extractedB64);\n      return decoded;\n    }\n    throw new Error('End of message marker not found. Message length: ' + message.length);\n  } catch (err) {\n    throw new Error('Failed to extract data from image: ' + err.message);\n  }\n};\n\n// -------------------- VIDEO HELPERS --------------------\n\n// Extract a frame from a video File (Blob) at a specific timestamp (seconds).\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\n  return new Promise((resolve, reject) => {\n    const video = document.createElement('video');\n    video.muted = true;\n    video.preload = 'auto';\n    const cleanup = () => {\n      try {\n        URL.revokeObjectURL(video.src);\n      } catch (_) {}\n    };\n    video.onerror = () => {\n      cleanup();\n      reject(new Error('Video load error'));\n    };\n    video.onloadedmetadata = () => {\n      // ensure timestamp is within bounds\n      let t = frameTimestamp;\n      if (typeof t !== 'number' || isNaN(t)) t = 1;\n      if (t < 0) t = 0;\n      if (t > video.duration) t = Math.max(0, video.duration - 0.1);\n\n      // seek to desired time\n      const onseeked = () => {\n        try {\n          const canvas = document.createElement('canvas');\n          canvas.width = video.videoWidth;\n          canvas.height = video.videoHeight;\n          const ctx = canvas.getContext('2d');\n          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n          const dataUrl = canvas.toDataURL('image/png');\n          cleanup();\n          video.removeEventListener('seeked', onseeked);\n          resolve(dataUrl);\n        } catch (err) {\n          cleanup();\n          reject(new Error('Failed to capture frame: ' + err.message));\n        }\n      };\n      video.addEventListener('seeked', onseeked);\n      // set currentTime AFTER loadedmetadata\n      try {\n        video.currentTime = t;\n      } catch (err) {\n        // some browsers may throw if currentTime is set too early\n        // fallback: just resolve first frame\n        video.play().then(() => {\n          video.pause();\n          onseeked();\n        }).catch(() => {\n          reject(new Error('Failed to seek video: ' + err.message));\n        });\n      }\n    };\n    video.src = URL.createObjectURL(videoFile);\n  });\n};\n\n// Hide message in a random video frame and return stego-frame dataURL and metadata\nexport const hideDataInVideoFrame = async (videoFile, data) => {\n  try {\n    const video = document.createElement('video');\n    video.preload = 'metadata';\n    video.src = URL.createObjectURL(videoFile);\n    return new Promise((resolve, reject) => {\n      video.onloadedmetadata = async () => {\n        try {\n          const duration = video.duration || 1;\n          const randomFrameTimestamp = Math.max(0.5, Math.min(duration - 0.5, Math.random() * duration));\n          // extract frame\n          const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\n          // hide data in frame (data will be base64-encoded inside hideDataInImage)\n          const stegoFrame = await hideDataInImage(frameDataUrl, data);\n          const frameMetadata = {\n            frameTimestamp: randomFrameTimestamp\n          };\n          resolve({\n            stegoFrame,\n            frameMetadata,\n            originalVideo: videoFile\n          });\n        } catch (err) {\n          reject(err);\n        }\n      };\n      video.onerror = err => {\n        reject(new Error('Video metadata load error: ' + ((err === null || err === void 0 ? void 0 : err.message) || err)));\n      };\n    });\n  } catch (err) {\n    throw new Error('Failed to process video: ' + err.message);\n  }\n};\n\n// Extract hidden payload from video using stego frame or timestamp\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\n  try {\n    const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\n    const extracted = await extractDataFromImage(frameDataUrl);\n    return extracted;\n  } catch (err) {\n    throw new Error('Failed to extract data from video: ' + err.message);\n  }\n};","map":{"version":3,"names":["forge","encryptMessage","message","recipientPublicKeyPem","aesKey","random","getBytesSync","iv","cipher","createCipher","start","update","util","createBuffer","finish","encryptedMessage","output","getBytes","recipientPublicKey","pki","publicKeyFromPem","encryptedAesKey","encrypt","encode64","encryptedKey","decryptMessage","encryptedPayload","privateKeyPem","privateKey","privateKeyFromPem","decrypt","decode64","decipher","createDecipher","toString","END_OF_MESSAGE","utf8ToBase64","str","btoa","unescape","encodeURIComponent","base64ToUtf8","b64","decodeURIComponent","escape","atob","getImageData","dataUrl","Promise","resolve","reject","img","Image","onload","canvas","document","createElement","width","height","ctx","getContext","drawImage","imageData","onerror","err","Error","src","hideDataInImage","imageDataUrl","data","payload","messageBits","i","length","charCode","charCodeAt","padStart","pixels","numPixels","capacityBits","bitIndex","px","bit","putImageData","toDataURL","extractDataFromImage","bits","console","log","byte","substring","code","parseInt","String","fromCharCode","eomIndex","indexOf","extractedB64","decoded","extractVideoFrame","videoFile","frameTimestamp","video","muted","preload","cleanup","URL","revokeObjectURL","_","onloadedmetadata","t","isNaN","duration","Math","max","onseeked","videoWidth","videoHeight","removeEventListener","addEventListener","currentTime","play","then","pause","catch","createObjectURL","hideDataInVideoFrame","randomFrameTimestamp","min","frameDataUrl","stegoFrame","frameMetadata","originalVideo","extractDataFromVideo","extracted"],"sources":["D:/secure-chat-app/frontend/src/utils/crypto.js"],"sourcesContent":["// src/utils/crypto.js\r\nimport forge from 'node-forge';\r\n\r\n// -------------------- Crypto helpers --------------------\r\nexport const encryptMessage = (message, recipientPublicKeyPem) => {\r\n  const aesKey = forge.random.getBytesSync(32);\r\n  const iv = forge.random.getBytesSync(16);\r\n\r\n  const cipher = forge.cipher.createCipher('AES-CBC', aesKey);\r\n  cipher.start({ iv });\r\n  cipher.update(forge.util.createBuffer(message, 'utf8'));\r\n  cipher.finish();\r\n  const encryptedMessage = cipher.output.getBytes();\r\n\r\n  const recipientPublicKey = forge.pki.publicKeyFromPem(recipientPublicKeyPem);\r\n  const encryptedAesKey = recipientPublicKey.encrypt(aesKey, 'RSA-OAEP');\r\n\r\n  return {\r\n    iv: forge.util.encode64(iv),\r\n    encryptedKey: forge.util.encode64(encryptedAesKey),\r\n    encryptedMessage: forge.util.encode64(encryptedMessage),\r\n  };\r\n};\r\n\r\nexport const decryptMessage = (encryptedPayload, privateKeyPem) => {\r\n  const { iv, encryptedKey, encryptedMessage } = encryptedPayload;\r\n  const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\r\n  const aesKey = privateKey.decrypt(forge.util.decode64(encryptedKey), 'RSA-OAEP');\r\n\r\n  const decipher = forge.cipher.createDecipher('AES-CBC', aesKey);\r\n  decipher.start({ iv: forge.util.decode64(iv) });\r\n  decipher.update(forge.util.createBuffer(forge.util.decode64(encryptedMessage)));\r\n  decipher.finish();\r\n\r\n  return decipher.output.toString('utf8');\r\n};\r\n\r\n// -------------------- Stego helpers --------------------\r\nconst END_OF_MESSAGE = '$$EOM$$';\r\n\r\n// UTF-8 <-> base64 helpers that are safe for arbitrary Unicode\r\nconst utf8ToBase64 = (str) => {\r\n  // encodeURIComponent -> percent-encoding -> decode percent into raw bytes for btoa\r\n  return btoa(unescape(encodeURIComponent(str)));\r\n};\r\nconst base64ToUtf8 = (b64) => {\r\n  return decodeURIComponent(escape(atob(b64)));\r\n};\r\n\r\n// load an image (dataURL) and return imageData + canvas context\r\nconst getImageData = (dataUrl) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = img.width;\r\n      canvas.height = img.height;\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.drawImage(img, 0, 0);\r\n      resolve({ imageData: ctx.getImageData(0, 0, canvas.width, canvas.height), ctx });\r\n    };\r\n    img.onerror = (err) => reject(new Error('Image load error: ' + err?.message || err));\r\n    img.src = dataUrl;\r\n  });\r\n};\r\n\r\n// -------------------- Image steganography (3 bits per pixel: R,G,B) --------------------\r\n\r\n// hideDataInImage: imageDataUrl (dataURL string), data: string (already JSON/stringified)\r\n// We will base64-encode the data inside this function to make it safe for embedding.\r\nexport const hideDataInImage = async (imageDataUrl, data) => {\r\n  // encode data as base64 (UTF-8 safe) and append marker\r\n  const payload = utf8ToBase64(data) + END_OF_MESSAGE;\r\n  // convert to bit string\r\n  let messageBits = '';\r\n  for (let i = 0; i < payload.length; i++) {\r\n    const charCode = payload.charCodeAt(i);\r\n    messageBits += charCode.toString(2).padStart(8, '0');\r\n  }\r\n\r\n  const { imageData, ctx } = await getImageData(imageDataUrl);\r\n  const pixels = imageData.data; // RGBA array\r\n  const numPixels = pixels.length / 4;\r\n  const capacityBits = numPixels * 3; // using R,G,B LSBs\r\n\r\n  if (messageBits.length > capacityBits) {\r\n    throw new Error(\r\n      `Image too small. Need ${messageBits.length} bits but only ${capacityBits} bits available. ` +\r\n        `Use a larger image or shorten the message.`\r\n    );\r\n  }\r\n\r\n  let bitIndex = 0;\r\n  // iterate pixels, set LSBs of R,G,B channels\r\n  for (let px = 0; px < pixels.length && bitIndex < messageBits.length; px += 4) {\r\n    // R channel\r\n    if (bitIndex < messageBits.length) {\r\n      const bit = +messageBits[bitIndex++];\r\n      pixels[px] = (pixels[px] & 0xfe) | bit;\r\n    }\r\n    // G channel\r\n    if (bitIndex < messageBits.length) {\r\n      const bit = +messageBits[bitIndex++];\r\n      pixels[px + 1] = (pixels[px + 1] & 0xfe) | bit;\r\n    }\r\n    // B channel\r\n    if (bitIndex < messageBits.length) {\r\n      const bit = +messageBits[bitIndex++];\r\n      pixels[px + 2] = (pixels[px + 2] & 0xfe) | bit;\r\n    }\r\n    // leave alpha channel unchanged (px+3)\r\n  }\r\n\r\n  ctx.putImageData(imageData, 0, 0);\r\n  return ctx.canvas.toDataURL('image/png');\r\n};\r\n\r\n// extractDataFromImage: returns the base64-encoded payload (WITHOUT END marker) as a string\r\nexport const extractDataFromImage = async (imageDataUrl) => {\r\n  try {\r\n    const { imageData } = await getImageData(imageDataUrl);\r\n    const pixels = imageData.data;\r\n    const numPixels = pixels.length / 4;\r\n    const capacityBits = numPixels * 3;\r\n\r\n    // read bits from R,G,B LSBs\r\n    let bits = '';\r\n    for (let px = 0; px < pixels.length; px += 4) {\r\n      bits += (pixels[px] & 1).toString();\r\n      bits += (pixels[px + 1] & 1).toString();\r\n      bits += (pixels[px + 2] & 1).toString();\r\n    }\r\n\r\n    console.log('Extracted message bits length:', bits.length);\r\n\r\n    // convert bits to chars\r\n    let message = '';\r\n    for (let i = 0; i < bits.length; i += 8) {\r\n      const byte = bits.substring(i, i + 8);\r\n      if (byte.length < 8) break;\r\n      const code = parseInt(byte, 2);\r\n      message += String.fromCharCode(code);\r\n    }\r\n\r\n    console.log('Decoded message length:', message.length);\r\n    console.log('Looking for END_OF_MESSAGE marker:', END_OF_MESSAGE);\r\n    const eomIndex = message.indexOf(END_OF_MESSAGE);\r\n    console.log('EOM index:', eomIndex);\r\n\r\n    if (eomIndex !== -1) {\r\n      const extractedB64 = message.substring(0, eomIndex);\r\n      // convert base64 back to utf8 string\r\n      const decoded = base64ToUtf8(extractedB64);\r\n      return decoded;\r\n    }\r\n\r\n    throw new Error('End of message marker not found. Message length: ' + message.length);\r\n  } catch (err) {\r\n    throw new Error('Failed to extract data from image: ' + err.message);\r\n  }\r\n};\r\n\r\n// -------------------- VIDEO HELPERS --------------------\r\n\r\n// Extract a frame from a video File (Blob) at a specific timestamp (seconds).\r\nexport const extractVideoFrame = (videoFile, frameTimestamp) => {\r\n  return new Promise((resolve, reject) => {\r\n    const video = document.createElement('video');\r\n    video.muted = true;\r\n    video.preload = 'auto';\r\n\r\n    const cleanup = () => {\r\n      try {\r\n        URL.revokeObjectURL(video.src);\r\n      } catch (_) {}\r\n    };\r\n\r\n    video.onerror = () => {\r\n      cleanup();\r\n      reject(new Error('Video load error'));\r\n    };\r\n\r\n    video.onloadedmetadata = () => {\r\n      // ensure timestamp is within bounds\r\n      let t = frameTimestamp;\r\n      if (typeof t !== 'number' || isNaN(t)) t = 1;\r\n      if (t < 0) t = 0;\r\n      if (t > video.duration) t = Math.max(0, video.duration - 0.1);\r\n\r\n      // seek to desired time\r\n      const onseeked = () => {\r\n        try {\r\n          const canvas = document.createElement('canvas');\r\n          canvas.width = video.videoWidth;\r\n          canvas.height = video.videoHeight;\r\n          const ctx = canvas.getContext('2d');\r\n          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n          const dataUrl = canvas.toDataURL('image/png');\r\n          cleanup();\r\n          video.removeEventListener('seeked', onseeked);\r\n          resolve(dataUrl);\r\n        } catch (err) {\r\n          cleanup();\r\n          reject(new Error('Failed to capture frame: ' + err.message));\r\n        }\r\n      };\r\n\r\n      video.addEventListener('seeked', onseeked);\r\n      // set currentTime AFTER loadedmetadata\r\n      try {\r\n        video.currentTime = t;\r\n      } catch (err) {\r\n        // some browsers may throw if currentTime is set too early\r\n        // fallback: just resolve first frame\r\n        video.play().then(() => {\r\n          video.pause();\r\n          onseeked();\r\n        }).catch(() => {\r\n          reject(new Error('Failed to seek video: ' + err.message));\r\n        });\r\n      }\r\n    };\r\n\r\n    video.src = URL.createObjectURL(videoFile);\r\n  });\r\n};\r\n\r\n// Hide message in a random video frame and return stego-frame dataURL and metadata\r\nexport const hideDataInVideoFrame = async (videoFile, data) => {\r\n  try {\r\n    const video = document.createElement('video');\r\n    video.preload = 'metadata';\r\n    video.src = URL.createObjectURL(videoFile);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      video.onloadedmetadata = async () => {\r\n        try {\r\n          const duration = video.duration || 1;\r\n          const randomFrameTimestamp = Math.max(0.5, Math.min(duration - 0.5, Math.random() * duration));\r\n          // extract frame\r\n          const frameDataUrl = await extractVideoFrame(videoFile, randomFrameTimestamp);\r\n          // hide data in frame (data will be base64-encoded inside hideDataInImage)\r\n          const stegoFrame = await hideDataInImage(frameDataUrl, data);\r\n          const frameMetadata = { frameTimestamp: randomFrameTimestamp };\r\n\r\n          resolve({\r\n            stegoFrame,\r\n            frameMetadata,\r\n            originalVideo: videoFile,\r\n          });\r\n        } catch (err) {\r\n          reject(err);\r\n        }\r\n      };\r\n\r\n      video.onerror = (err) => {\r\n        reject(new Error('Video metadata load error: ' + (err?.message || err)));\r\n      };\r\n    });\r\n  } catch (err) {\r\n    throw new Error('Failed to process video: ' + err.message);\r\n  }\r\n};\r\n\r\n// Extract hidden payload from video using stego frame or timestamp\r\nexport const extractDataFromVideo = async (videoFile, frameTimestamp) => {\r\n  try {\r\n    const frameDataUrl = await extractVideoFrame(videoFile, frameTimestamp);\r\n    const extracted = await extractDataFromImage(frameDataUrl);\r\n    return extracted;\r\n  } catch (err) {\r\n    throw new Error('Failed to extract data from video: ' + err.message);\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}